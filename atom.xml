<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chreem&#39;s Blog</title>
  
  <subtitle>Single dog, single dog, single all the day.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chreem.github.io/"/>
  <updated>2020-06-11T08:48:53.027Z</updated>
  <id>https://chreem.github.io/</id>
  
  <author>
    <name>Chreem</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker-compose配置二维码登录环境</title>
    <link href="https://chreem.github.io/2018/06/29/20180629-docker-compose-for-qrcode/"/>
    <id>https://chreem.github.io/2018/06/29/20180629-docker-compose-for-qrcode/</id>
    <published>2018-06-29T20:33:13.000Z</published>
    <updated>2020-06-11T08:48:53.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker-compose-for-QRCode-Login"><a href="#docker-compose-for-QRCode-Login" class="headerlink" title="docker-compose for QRCode Login"></a>docker-compose for QRCode Login</h1><p>恰逢技术总监问我二维码登录，有没啥想法。作为需要多个服务配合完成的服务，正好拿docker-compose写一下：</p><p>本篇以自己写的二维码登录为例介绍一下<a href="https://github.com/Chreem/todo-list/blob/master/qrcode-login/docker-compose.yml" target="_blank" rel="noopener">常见配置</a></p><h2 id="所需部件"><a href="#所需部件" class="headerlink" title="所需部件"></a>所需部件</h2><ul><li><code>nginx</code> 为多个服务提供反向代理</li><li><code>redis</code> 暂存global login id及user login token</li><li><code>node</code> 提供登录及推送登录信息</li></ul><a id="more"></a><h1 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h1><p>所有配置参数直接参考官方文档，某些会略微说明，不做赘述</p><h2 id="docker-volume"><a href="#docker-volume" class="headerlink" title="docker volume"></a>docker volume</h2><pre><code>每个容器创建时会同时创建数据卷，the same as created by docker-compose  不同的是单纯`docker-compose down`不会删除数据卷，需要加上`-v`参数才会连带删除数据卷  主动创建的外部卷依然得手动删除</code></pre><h2 id="multi-bridge"><a href="#multi-bridge" class="headerlink" title="multi bridge"></a>multi bridge</h2><pre><code>即使看起来是路由可达，bridge模式下的多个网桥之间依然不允许通信，某个容器需要同时访问最好靠加入两个网桥，即：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.10</span></span><br></pre></td></tr></table></figure></code></pre><h2 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h2><pre><code>美其名曰暴露端口，但实际上即使不加这条，其他容器同样能正常访问，主要功能应该是使用`docker ps -a`时能直观看到端口吧，emmmmm...</code></pre><h2 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h2><pre><code>依赖服务，如本篇`auth_server`需要用到redis暂存sid&amp;uid，需要redis先于他启动</code></pre><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><pre><code>尽量不用build&amp;Dockerfile构建，因为凭空多管理一个image反而成为累赘。不得不用build完成的复杂场景，暂时没遇到使用`docker-compose down --rmi local`能同时移除build参数构建的image</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;docker-compose-for-QRCode-Login&quot;&gt;&lt;a href=&quot;#docker-compose-for-QRCode-Login&quot; class=&quot;headerlink&quot; title=&quot;docker-compose for QRCode Login&quot;&gt;&lt;/a&gt;docker-compose for QRCode Login&lt;/h1&gt;&lt;p&gt;恰逢技术总监问我二维码登录，有没啥想法。作为需要多个服务配合完成的服务，正好拿docker-compose写一下：&lt;/p&gt;
&lt;p&gt;本篇以自己写的二维码登录为例介绍一下&lt;a href=&quot;https://github.com/Chreem/todo-list/blob/master/qrcode-login/docker-compose.yml&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;常见配置&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;所需部件&quot;&gt;&lt;a href=&quot;#所需部件&quot; class=&quot;headerlink&quot; title=&quot;所需部件&quot;&gt;&lt;/a&gt;所需部件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nginx&lt;/code&gt; 为多个服务提供反向代理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis&lt;/code&gt; 暂存global login id及user login token&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node&lt;/code&gt; 提供登录及推送登录信息&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="daily" scheme="https://chreem.github.io/categories/daily/"/>
    
    
      <category term="docker" scheme="https://chreem.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>自行签发CA证书</title>
    <link href="https://chreem.github.io/2018/06/28/20180628-self-ca/"/>
    <id>https://chreem.github.io/2018/06/28/20180628-self-ca/</id>
    <published>2018-06-28T22:12:09.000Z</published>
    <updated>2020-06-11T08:48:53.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自签发CA证书-for-HTTPS"><a href="#自签发CA证书-for-HTTPS" class="headerlink" title="自签发CA证书 for HTTPS"></a>自签发CA证书 for HTTPS</h1><p>大部分教程抄来抄去，都是根证书下继续签发给某个组织的形式<br>仅做测试、规模不大时，直接签发根证书即可，无需继续下发</p><h2 id="Create-Root-CA"><a href="#Create-Root-CA" class="headerlink" title="Create Root CA"></a>Create Root CA</h2><ol><li><p>写好配置文件conf.cnf，预置SAN信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line"></span><br><span class="line">[ SAN ]</span><br><span class="line">subjectAltName &#x3D; DNS:*.chreem.club,DNS:chreem.club</span><br></pre></td></tr></table></figure></li><li><p>生成rsa密钥</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl genrsa -des3 -out server.enc.key 2048   <span class="comment"># 生成rsa</span></span><br><span class="line">&gt; password</span><br><span class="line">&gt; openssl rsa -<span class="keyword">in</span> server.enc.key -out server.key    <span class="comment"># 写入密码</span></span><br></pre></td></tr></table></figure></li><li><p>生成证书</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl req -new -sha256  \</span><br><span class="line">    -x509 \</span><br><span class="line">    -days 36500 \</span><br><span class="line">    -key server.key \</span><br><span class="line">    -subj <span class="string">"/C=CN/ST=Hubei/L=Wuhan/O=ChreemTech/OU=FS/CN=chreem.club"</span> \</span><br><span class="line">    -extensions SAN \</span><br><span class="line">    -config &lt;(cat ./conf.cnf) \</span><br><span class="line">    -out server.crt</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自签发CA证书-for-HTTPS&quot;&gt;&lt;a href=&quot;#自签发CA证书-for-HTTPS&quot; class=&quot;headerlink&quot; title=&quot;自签发CA证书 for HTTPS&quot;&gt;&lt;/a&gt;自签发CA证书 for HTTPS&lt;/h1&gt;&lt;p&gt;大部分教程抄来抄去，
      
    
    </summary>
    
    
      <category term="daily" scheme="https://chreem.github.io/categories/daily/"/>
    
    
      <category term="ca" scheme="https://chreem.github.io/tags/ca/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器网络</title>
    <link href="https://chreem.github.io/2017/12/13/20171213-docker-container-ip/"/>
    <id>https://chreem.github.io/2017/12/13/20171213-docker-container-ip/</id>
    <published>2017-12-13T09:14:23.000Z</published>
    <updated>2020-06-11T08:48:53.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker容器网络"><a href="#Docker容器网络" class="headerlink" title="Docker容器网络"></a>Docker容器网络</h1><p>linux下的docker默认创建网络：</p><blockquote><p>docker0, 172.17.0.0/16</p></blockquote><p>可以将运行linux的宿主机看做路由器, 其上的docker0接口连接一台交换机与各容器相连:</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">                +———————————+               +————+</span></span><br><span class="line"><span class="code">        1.1.1.1 |R          |               | SW |       +—container1—+</span></span><br><span class="line">public network interface    |               |  +----------172.17.0.11 |</span><br><span class="line"><span class="code">                |           |172.17.0.1     |  | |       +————————————+</span></span><br><span class="line"><span class="code">                |         docker0--------------+ |</span></span><br><span class="line"><span class="code">                |           |               |  | |       +—container2—+</span></span><br><span class="line"><span class="code">                +———————————+               |  +----------172.17.0.12 |</span></span><br><span class="line"><span class="code">                                            |    |       +————————————+</span></span><br><span class="line"><span class="code">                                            +————+</span></span><br></pre></td></tr></table></figure><p>详情可参照文档 <a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="noopener">Docker Network Configuration Documentation</a></p><a id="more"></a><h1 id="创建网络并为容器指定IP"><a href="#创建网络并为容器指定IP" class="headerlink" title="创建网络并为容器指定IP"></a>创建网络并为容器指定IP</h1><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><p>和各虚拟机大厂网络类似, 可自定义4种模式, 默认bridge <del>从没用过另外3种</del></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network create --subnet=192.168.1.0/24 [SubnetName]      <span class="comment"># 创建</span></span><br><span class="line">docker network ls                                               <span class="comment"># 查看已创建的网络名称及模式</span></span><br></pre></td></tr></table></figure><p>桥接网络可直接通过<code>ifconfig</code>查看其详情</p><h2 id="容器IP"><a href="#容器IP" class="headerlink" title="容器IP"></a>容器IP</h2><p>在<code>run</code>命令中加上<code>--network [SubnetName]</code>即可指定容器运行的网络. 同时, 需要指定IP的话, 此命令为必选项.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t -v [/physical/site:/container/site] --network [SubnetName] --ip [X.X.X.X] [ImageName] bash</span><br></pre></td></tr></table></figure><h2 id="inspect命令"><a href="#inspect命令" class="headerlink" title="inspect命令"></a>inspect命令</h2><p><code>inspect</code>命令主要作用是将容器的各项属性通过json格式返回, 而其中包括了容器IP, 所以通常查看容器IP可以通过<code>inspect</code>的<code>--format</code>参数来看到:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect [ContainerID]</span><br><span class="line">&gt; [</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="string">"NetworkSettings"</span>:&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="string">"IPAddress"</span>:<span class="string">"172.17.0.2"</span>,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">$ docker inspect -f <span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> [ContainerID]</span><br><span class="line">&gt; 172.17.0.2</span><br></pre></td></tr></table></figure><p>但docker会映射容器名作为host条目，内部直接使用容器名即可访问其他容器，且通常会指定ip</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><code>--ip X.X.X.X</code>只能在用户定义网络上指定IP, 默认网络只能自动分配</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker容器网络&quot;&gt;&lt;a href=&quot;#Docker容器网络&quot; class=&quot;headerlink&quot; title=&quot;Docker容器网络&quot;&gt;&lt;/a&gt;Docker容器网络&lt;/h1&gt;&lt;p&gt;linux下的docker默认创建网络：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker0, 172.17.0.0/16&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以将运行linux的宿主机看做路由器, 其上的docker0接口连接一台交换机与各容器相连:&lt;/p&gt;
&lt;figure class=&quot;highlight md&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;                +———————————+               +————+&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;        1.1.1.1 |R          |               | SW |       +—container1—+&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public network interface    |               |  +----------172.17.0.11 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;                |           |172.17.0.1     |  | |       +————————————+&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;                |         docker0--------------+ |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;                |           |               |  | |       +—container2—+&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;                +———————————+               |  +----------172.17.0.12 |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;                                            |    |       +————————————+&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;                                            +————+&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;详情可参照文档 &lt;a href=&quot;https://docs.docker.com/engine/userguide/networking/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker Network Configuration Documentation&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="knowledge" scheme="https://chreem.github.io/categories/knowledge/"/>
    
    
      <category term="docker" scheme="https://chreem.github.io/tags/docker/"/>
    
      <category term="network" scheme="https://chreem.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>game2048</title>
    <link href="https://chreem.github.io/2017/11/13/20171113-game2048/"/>
    <id>https://chreem.github.io/2017/11/13/20171113-game2048/</id>
    <published>2017-11-13T14:52:35.000Z</published>
    <updated>2020-06-11T08:48:53.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最最简单的2048小游戏"><a href="#最最简单的2048小游戏" class="headerlink" title="最最简单的2048小游戏"></a>最最简单的2048小游戏</h1><p>问题:</p><ul><li>喜闻乐见的深度监视与视图改变</li><li>生成数字的方式改变(相比问题更应该叫改动)</li><li>计算逻辑</li><li>[依然未解决]动画</li></ul><p>今后可能添加:</p><ul><li>replay</li><li>…</li></ul><p><img src="/images/game2048.png" alt="2048"></p><a id="more"></a><h1 id="计算逻辑"><a href="#计算逻辑" class="headerlink" title="计算逻辑"></a>计算逻辑</h1><p>这个部分, 当做大头来说可真太浪费了, 代码连注释也就不到30行</p><ol><li><p>先按照移动方向分各个行列数组, 计算逻辑按数组依次进行</p></li><li><p>堆栈暂存计算结果, 通过游标判断该入栈还是相加, 步骤:</p> <figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">计算:</span><br><span class="line">遍历第一步传入的数组</span><br><span class="line">元素为0则continue</span><br><span class="line">堆栈游标对应位置undefined则该元素入栈</span><br><span class="line">对应位置与本次数字相等则*=2, 记录计算结果作为得分, 游标++</span><br><span class="line">否则元素入栈, 且游标指向该元素(游标++)</span><br><span class="line"></span><br><span class="line">调整:</span><br><span class="line">完成遍历后根据源数组长度在堆栈前补全0</span><br><span class="line">堆栈元素依次出栈即为计算结果</span><br><span class="line"></span><br><span class="line">返回值:</span><br><span class="line">结果</span><br><span class="line">得分</span><br><span class="line">结果与传入数组不等则未移动任何元素(用于判断是否该生成新数字)</span><br></pre></td></tr></table></figure></li><li><p>完全没怀疑自己计算逻辑有问题才导致动画难做</p></li></ol><h1 id="相比此前的进步"><a href="#相比此前的进步" class="headerlink" title="相比此前的进步"></a>相比此前的进步</h1><p>和扫雷相比重写了二维数组随机位置生成数字的逻辑, 使其能在更小的棋盘上有效运行</p><ol><li><p>此前的扫雷<br> 通过随机[x,y]在任意位置生成, 若生成的[x,y]位置已有数字则此次生成失败, 连续10次生成成功则退出循环</p></li><li><p>本次2048数字<br> 先遍历一次所有格子, 将空位坐标存入数组<br> min(需要生成的个数, 数组长度)<br> 根据该数组长度随机其下标, 取出下标对应的元素并在该位置生成数字<br> 重复即可</p></li></ol><h1 id="拆分功能模块"><a href="#拆分功能模块" class="headerlink" title="拆分功能模块"></a>拆分功能模块</h1><p>此前把所有逻辑都写在.vue里导致vue臃肿, 曾经尝试写一个vue对象构造器来分离各部分代码而不是塞在一个Obj里, 但随后不了了之…</p><h1 id="可能增加的功能"><a href="#可能增加的功能" class="headerlink" title="可能增加的功能"></a>可能增加的功能</h1><p>正因为游戏逻辑抽出默认属性从而使之能进行更大棋盘(如5<em>5, 6</em>6等)的游戏<br>出现4的概率作为参数可选, 以调整难度<br>此外生成数字也可以稍作修改达到在<code>指定位置生成对应数字</code>的效果, 配合记录本局点出现的位置及移动方向, 从而作为replay的基础</p><p>所以可能的功能:</p><ol><li><p>replay</p></li><li><p>重播中途觉得本步不妥可接着当前位置继续</p><p> 但要撤回至上一步则只靠点和方向无法还原, 似乎只能记下每次移动后全盘的情况, 额外开销略大, 所以本功能犹豫不决, 即使真要做也只会复原有限步而不会全盘记录(众: 就是不想做, 我: puchi!)</p></li><li><p>游戏范围调整, 4*4不满足还可以更高</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;最最简单的2048小游戏&quot;&gt;&lt;a href=&quot;#最最简单的2048小游戏&quot; class=&quot;headerlink&quot; title=&quot;最最简单的2048小游戏&quot;&gt;&lt;/a&gt;最最简单的2048小游戏&lt;/h1&gt;&lt;p&gt;问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;喜闻乐见的深度监视与视图改变&lt;/li&gt;
&lt;li&gt;生成数字的方式改变(相比问题更应该叫改动)&lt;/li&gt;
&lt;li&gt;计算逻辑&lt;/li&gt;
&lt;li&gt;[依然未解决]动画&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今后可能添加:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;replay&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/game2048.png&quot; alt=&quot;2048&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="games" scheme="https://chreem.github.io/categories/games/"/>
    
    
      <category term="vue" scheme="https://chreem.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>VPS setup</title>
    <link href="https://chreem.github.io/2017/11/13/20171113-vps-setup/"/>
    <id>https://chreem.github.io/2017/11/13/20171113-vps-setup/</id>
    <published>2017-11-13T13:07:49.000Z</published>
    <updated>2020-06-11T08:48:53.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VPS各种基础服务"><a href="#VPS各种基础服务" class="headerlink" title="VPS各种基础服务"></a>VPS各种基础服务</h1><p>正巧最近准备换VPS, 倒腾一下自己用了哪些东西, 万一下次要换不用到处找贴</p><p>整理下顺序:</p><ol><li>VPS页绑定SSH Key以及防火墙实例, 默认放开80/443/3389/5432端口, 后续有需要再追加</li><li>修改SSH端口 port:5432</li><li><a href="#RDP">开启BBR加速, SS port:3389</a></li><li><a href="#Nginx">Nginx</a></li><li><a href="#Docker">docker(虚拟机, 因为还没去看更高级的功能😭)</a></li><li>域名商页面修改A记录</li><li>[增加虚拟内存](#Virtual Memory)</li></ol><a id="more"></a><h2 id="各种服务"><a href="#各种服务" class="headerlink" title="各种服务"></a>各种服务</h2><p>绑定实例放开端口没啥可说的, SSH端口直接<code>vi /etc/ssh/sshd_config</code>下找到<code>Port 22</code>改掉就好<br>修改域名记录也无非改改对应的VPS IP而已</p><h3 id="RDP"><a href="#RDP" class="headerlink" title="RDP"></a>RDP</h3><p>没啥可介绍的, 这破锅下都该会<br>此前各种FreeGate, GAE, SQSX都多少用过, 果然还是酸酸乳最好用, 备选之一v2ray</p><ol><li><p>linux内核版本≥4.9</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; uname -r                                          <span class="comment"># 查看内核版本</span></span><br><span class="line">4.4.0-57-generic</span><br><span class="line">&gt; apt-cache search linux-image                      <span class="comment"># 查看可下载的内核</span></span><br><span class="line">&gt; apt-get install linux-images-4.10.0-21-generic</span><br><span class="line">&gt; apt-get remove linux-images-4.4.0-57-generic</span><br><span class="line">&gt; reboot</span><br></pre></td></tr></table></figure></li><li><p>启用bbr</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; vi /etc/sysctl.conf                   <span class="comment"># 在最后加上:</span></span><br><span class="line">net.core.default_qdisc=fq</span><br><span class="line">net.ipv4.tcp_congestion_control=bbr</span><br><span class="line">&gt; sysctl -p                             <span class="comment"># 保存退出并执行此条</span></span><br><span class="line">&gt; lsmod | grep bbr                      <span class="comment"># 查看是否有类似如下输出</span></span><br><span class="line">tcp_bbr                20480  3</span><br></pre></td></tr></table></figure></li><li><p>服务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; apt-get install rdp(远程滑稽桌面)</span><br><span class="line">&gt; vi rdpserver.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span> : <span class="string">"vps的ip"</span>,              // 不能为0.0.0.0</span><br><span class="line">    <span class="string">"server_port"</span> : 想使用的端口,       // 3389, 配置远程桌面呀(滑稽</span><br><span class="line">    <span class="string">"local_address"</span> : <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="string">"local_port"</span> : 1080,</span><br><span class="line">    <span class="string">"password"</span> : <span class="string">"如名"</span>,</span><br><span class="line">    <span class="string">"timeout"</span> : 300,</span><br><span class="line">    <span class="string">"method"</span> : <span class="string">"加密方式"</span>,              // 通常为aes-256-cfb</span><br><span class="line">    <span class="string">"fast_open"</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; rdpserver -c rdpserver.json start     <span class="comment"># 运行服务</span></span><br><span class="line">&gt; nohup xxx(rdpserver xxx) &amp;            <span class="comment"># 或nohup后台运行</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ol><li><p>gzip, 去掉注释即可</p></li><li><p>常用配置</p><p> 上传证书后在对应页面下配置:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 反向代理配置</span></span><br><span class="line">upstream site&#123;</span><br><span class="line">    server 192.168.1.20:3000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 80端口转发至443</span></span><br><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 域名;</span><br><span class="line">    rewrite ^(.*)$ https://<span class="variable">$server_name</span><span class="variable">$1</span> permanent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name 域名;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静态资源配置</span></span><br><span class="line">    root /var/www/html;</span><br><span class="line">    index index.html;</span><br><span class="line">    error_page 403 404 = /error.json;</span><br><span class="line">    location / &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向代理配置(内部若使用https需对应修改, 不过正常情况应该不会...)</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://site;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 资源缓存</span></span><br><span class="line">    location ~* \.(ico|gif|jpg|jpeg|png|js|css|txt|xml|swf|wav|ttf)$ &#123;</span><br><span class="line">        proxy_pass http://site;     <span class="comment"># 视情况添加</span></span><br><span class="line">        access_log   off;</span><br><span class="line">        expires      3d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 证书配置</span></span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate .crt的路径;</span><br><span class="line">    ssl_certificate_key .key的路径;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>更高级的功能待日后研究<br>使用nginx反向代理故无需使用<code>-p 物理端口:容器端口</code></p><ol><li>创建自定义网络 <code>docker network create --subnet=192.168.1.0/24 SelfNet</code></li><li>运行容器并分配IP <code>docker run xxx -v 物理路径:容器内路径 --network SelfNet --ip 192.168.1.x 镜像名</code></li><li>进入运行中的容器 <code>docker exec -it 容器名 bash</code></li><li>离开容器不中断运行 <code>ctrl + p =&gt; ctrl + q</code></li></ol><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>因购入的2.5$只有512M内存, 跑node特别是build步骤各种error 137<br>大头全在构建上, 所以只要构建成功后续部署所需的内存就不会这么大了<br>于是增加虚拟内存妄图解决  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; free -m                                           <span class="comment"># 查看内存空间</span></span><br><span class="line">&gt; df -B M                                           <span class="comment"># 查看磁盘..</span></span><br><span class="line">&gt; dd <span class="keyword">if</span>=/dev/zero of=/.swapfile bs=1M count=1024    <span class="comment"># 建立1G的虚存文件</span></span><br><span class="line">&gt; mv .swapfile /root                                <span class="comment"># 文件随意处置, 如移动</span></span><br><span class="line">&gt; mkswap .swapfile                                  <span class="comment"># 将文件设为交换分区</span></span><br><span class="line">&gt; swapon .swapfile                                  <span class="comment"># 启用虚拟内存</span></span><br><span class="line">&gt; swapoff -v .swapfile                              <span class="comment"># 释放....</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;VPS各种基础服务&quot;&gt;&lt;a href=&quot;#VPS各种基础服务&quot; class=&quot;headerlink&quot; title=&quot;VPS各种基础服务&quot;&gt;&lt;/a&gt;VPS各种基础服务&lt;/h1&gt;&lt;p&gt;正巧最近准备换VPS, 倒腾一下自己用了哪些东西, 万一下次要换不用到处找贴&lt;/p&gt;
&lt;p&gt;整理下顺序:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VPS页绑定SSH Key以及防火墙实例, 默认放开80/443/3389/5432端口, 后续有需要再追加&lt;/li&gt;
&lt;li&gt;修改SSH端口 port:5432&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#RDP&quot;&gt;开启BBR加速, SS port:3389&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Nginx&quot;&gt;Nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Docker&quot;&gt;docker(虚拟机, 因为还没去看更高级的功能😭)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;域名商页面修改A记录&lt;/li&gt;
&lt;li&gt;[增加虚拟内存](#Virtual Memory)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="daily" scheme="https://chreem.github.io/categories/daily/"/>
    
    
      <category term="server" scheme="https://chreem.github.io/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>raspberry-site</title>
    <link href="https://chreem.github.io/2017/10/29/20171029-raspberry-site/"/>
    <id>https://chreem.github.io/2017/10/29/20171029-raspberry-site/</id>
    <published>2017-10-29T18:12:29.000Z</published>
    <updated>2020-06-11T08:48:53.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Raspberry-Site"><a href="#Raspberry-Site" class="headerlink" title="Raspberry Site"></a>Raspberry Site</h1><p>目前作为自用web server以及硬件研究服务器, 用了各种功能</p><h2 id="各种功能"><a href="#各种功能" class="headerlink" title="各种功能"></a>各种功能</h2><ol><li><p>静态资源服务</p><p> 原计划用一个跑在docker容器中的node/express来做, 不过docker部署不太顺利, 暂时忽略</p><p> apache2</p></li><li><p>GPIO Control</p><p> 之前用node fs象征性的写了写, 通过设置树莓派系统暴露出的/sys/gpio接口来控制<br> 然而<a href="https://github.com/jperkin/node-rpio" target="_blank" rel="noopener">别人家</a>通过bcm2835的c文件直接对内存操作，其Readme也给出了性能对比，遂放弃自己造轮子</p><p> rpio, express, socket.io</p></li><li><p>上述的配套UI</p><p> 为了从公网可访问，需要建立一台websocket server，且node服务与前端都加入这个server</p><p> socket.io-client</p></li></ol><a id="more"></a><h1 id="静态站点"><a href="#静态站点" class="headerlink" title="静态站点"></a>静态站点</h1><h2 id="Apache2-CORS"><a href="#Apache2-CORS" class="headerlink" title="Apache2 CORS"></a>Apache2 CORS</h2><p>不得不说apache的目录结构越来越像nginx了, 同样的xxx-available xxx-enable<br>apache2的目录结构和1相比变化不小, 不过变化再大也不关我啥事, 反正我也用不上😹</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 据说header模块默认开启, 但我的没, 怕是用了假apache</span></span><br><span class="line">&gt; a2enmod headers</span><br><span class="line">&gt; vim /etc/apache2/apache2.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到并将Header改为以下:</span></span><br><span class="line">&lt;Directory /var/www&gt;</span><br><span class="line">Options Indexes FollowSymLinks</span><br><span class="line">AllowOverride All</span><br><span class="line">Header <span class="built_in">set</span> Access-Control-Allow-Origin <span class="string">"*"</span></span><br><span class="line">Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查配置文件语法并重启</span></span><br><span class="line">&gt; apachectl -t</span><br><span class="line">&gt; service apache2 reload</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>不能使用类似express的<code>res.header(&#39;Access-Control-Allow-Origin&#39;, req.get(&#39;origin&#39;))</code>来设置Origin，仅仅只能作为静态资源服务  </p><h1 id="GPIO接口控制"><a href="#GPIO接口控制" class="headerlink" title="GPIO接口控制"></a>GPIO接口控制</h1><p>nodejs的gpio控制，目前唯一的作用是，开关灯😂</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Raspberry-Site&quot;&gt;&lt;a href=&quot;#Raspberry-Site&quot; class=&quot;headerlink&quot; title=&quot;Raspberry Site&quot;&gt;&lt;/a&gt;Raspberry Site&lt;/h1&gt;&lt;p&gt;目前作为自用web server以及硬件研究服务器, 用了各种功能&lt;/p&gt;
&lt;h2 id=&quot;各种功能&quot;&gt;&lt;a href=&quot;#各种功能&quot; class=&quot;headerlink&quot; title=&quot;各种功能&quot;&gt;&lt;/a&gt;各种功能&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;静态资源服务&lt;/p&gt;
&lt;p&gt; 原计划用一个跑在docker容器中的node/express来做, 不过docker部署不太顺利, 暂时忽略&lt;/p&gt;
&lt;p&gt; apache2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GPIO Control&lt;/p&gt;
&lt;p&gt; 之前用node fs象征性的写了写, 通过设置树莓派系统暴露出的/sys/gpio接口来控制&lt;br&gt; 然而&lt;a href=&quot;https://github.com/jperkin/node-rpio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;别人家&lt;/a&gt;通过bcm2835的c文件直接对内存操作，其Readme也给出了性能对比，遂放弃自己造轮子&lt;/p&gt;
&lt;p&gt; rpio, express, socket.io&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上述的配套UI&lt;/p&gt;
&lt;p&gt; 为了从公网可访问，需要建立一台websocket server，且node服务与前端都加入这个server&lt;/p&gt;
&lt;p&gt; socket.io-client&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="daily" scheme="https://chreem.github.io/categories/daily/"/>
    
    
      <category term="server" scheme="https://chreem.github.io/tags/server/"/>
    
      <category term="raspberry" scheme="https://chreem.github.io/tags/raspberry/"/>
    
  </entry>
  
  <entry>
    <title>文件上传及注意事项</title>
    <link href="https://chreem.github.io/2017/09/21/20170921-upload/"/>
    <id>https://chreem.github.io/2017/09/21/20170921-upload/</id>
    <published>2017-09-21T17:57:04.000Z</published>
    <updated>2020-06-11T08:48:53.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传及注意事项"><a href="#文件上传及注意事项" class="headerlink" title="文件上传及注意事项"></a>文件上传及注意事项</h1><p>站点登录认证可略微参考<a href="https://zhuanlan.zhihu.com/p/29101305" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29101305</a>，即Authorization字段<br>鉴权后来判断是否允许写入文件</p><p>涉及字段:  </p><table><thead><tr><th>名称</th><th>Value</th></tr></thead><tbody><tr><td>Access-Control-Allow-Credentials</td><td>true</td></tr><tr><td>Access-Control-Allow-Headers</td><td>Accept, Authorization, Content-Type, X-Requested-With, Range</td></tr><tr><td>Access-Control-Allow-Methods</td><td>GET,POST,PUT,PATCH,DELETE</td></tr><tr><td>Access-Control-Allow-Origin</td><td><code>http://localhost:8080</code></td></tr><tr><td>Authorization</td><td>xxx…</td></tr><tr><td>Cookie</td><td>xxx…</td></tr><tr><td>Content-Length</td><td>xxx…</td></tr><tr><td>Content-Type</td><td>application/json</td></tr><tr><td>Server</td><td>chr/0.0.1</td></tr><tr><td>X-Powered-By</td><td>Chreem</td></tr></tbody></table><a id="more"></a><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><ol><li><p>HTTP/1.1</p><p> 持久连接Connection: keep-alive<br> 管道机制: 多个资源复用一条TCP连接, 但一条连接中的资源顺序加载<br> 对应上条而使用Content-Length字段<br> 分块传输编码及Transfer-Encoding: chunked字段<br> GET,POST外的如PUT,PATCH,DELETE等字段</p></li><li><p>WebSocket</p><p> 通过HTTP/1.1握手, 相比HTTP/2的服务端推送更偏向于即时通讯</p></li><li><p>HTTP/2</p><p> 服务端推送, 相比HTTP/1.1客户端解析HTML再发出静态资源请求, HTTP/2可将HTML返回并主动推送静态资源</p></li></ol><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>为了配合后端验证, 保存用户加入的聊天室及权限以免每次请求都得连库验证, 依然使用了express-session, 需要客户端发送Cookie</p><p>服务端需提供CORS头, 为设置Cookie需 Credentials设置为true且 Origin不能为*</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">HEADERS: &#123;</span><br><span class="line">    <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="string">'true'</span>,</span><br><span class="line">    <span class="string">'Access-Control-Allow-Methods'</span>: <span class="string">'GET,POST,PUT,PATCH,DELETE'</span>,</span><br><span class="line">    <span class="string">'Access-Control-Allow-Headers'</span>: <span class="string">'Accept, Authorization, Content-Type, X-Requested-With, Range'</span>,</span><br><span class="line">    <span class="string">'Access-Control-Expose-Headers'</span>: <span class="string">'Content-Length'</span>,</span><br><span class="line">    <span class="string">'X-Powered-By'</span>: <span class="string">'Chreem &lt;chreem@qq.com&gt;'</span>,</span><br><span class="line">    <span class="string">'Server'</span>: <span class="string">'chr-server/0.0.1'</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    res.header(HEADERS);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, req.get(<span class="string">'origin'</span>)) <span class="comment">// DEBUG_MODE</span></span><br><span class="line">    <span class="keyword">return</span> req.method === <span class="string">'OPTIONS'</span> ? res.sendStatus(<span class="number">200</span>) : next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>客户端还需允许验证头withCredentials</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栗子axios</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h1 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h1><p>文件上传使用POST Content-Type: ‘multipart/form-data’<br>直接使用原生FormData可省去诸多麻烦:  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadFile</span>(<span class="params">&#123;fileName: <span class="built_in">String</span>, file: File, token: <span class="built_in">String</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (site.DEBUG_MODE) &#123;<span class="keyword">return</span> token&#125;</span><br><span class="line">    <span class="keyword">let</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">    formData.set(<span class="string">'key'</span>, fileName);</span><br><span class="line">    formData.set(<span class="string">'token'</span>, token);</span><br><span class="line">    formData.set(<span class="string">'file'</span>, file, fileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">'post'</span>, QINIU_UPLOAD_DOMAIN, <span class="literal">true</span>);</span><br><span class="line">    xhr.send(formData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终req.body形如:</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST http://upload.xxx/</span><br><span class="line">Content-Type: multipart/form-data; boundary=<span class="xml"><span class="tag">&lt;<span class="name">Boundary</span>&gt;</span></span></span><br><span class="line">--<span class="xml"><span class="tag">&lt;<span class="name">Boundary</span>&gt;</span></span></span><br><span class="line">Content-Disposition: form-data; name="key"</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">resource_key</span>&gt;</span></span></span><br><span class="line">--<span class="xml"><span class="tag">&lt;<span class="name">Boundary</span>&gt;</span></span></span><br><span class="line">Content-Disposition: form-data; name="token"</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">upload_token</span>&gt;</span></span></span><br><span class="line">--<span class="xml"><span class="tag">&lt;<span class="name">Boundary</span>&gt;</span></span></span><br><span class="line">Content-Disposition: form-data; name="file"; filename="[文件名]"</span><br><span class="line">Content-Type: <span class="xml"><span class="tag">&lt;<span class="name">MimeType</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">[文件内容]</span><br><span class="line">--<span class="xml"><span class="tag">&lt;<span class="name">Boundary</span>&gt;</span></span>--</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;文件上传及注意事项&quot;&gt;&lt;a href=&quot;#文件上传及注意事项&quot; class=&quot;headerlink&quot; title=&quot;文件上传及注意事项&quot;&gt;&lt;/a&gt;文件上传及注意事项&lt;/h1&gt;&lt;p&gt;站点登录认证可略微参考&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29101305&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/29101305&lt;/a&gt;，即Authorization字段&lt;br&gt;鉴权后来判断是否允许写入文件&lt;/p&gt;
&lt;p&gt;涉及字段:  &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Access-Control-Allow-Credentials&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Access-Control-Allow-Headers&lt;/td&gt;
&lt;td&gt;Accept, Authorization, Content-Type, X-Requested-With, Range&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Access-Control-Allow-Methods&lt;/td&gt;
&lt;td&gt;GET,POST,PUT,PATCH,DELETE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Access-Control-Allow-Origin&lt;/td&gt;
&lt;td&gt;&lt;code&gt;http://localhost:8080&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Authorization&lt;/td&gt;
&lt;td&gt;xxx…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cookie&lt;/td&gt;
&lt;td&gt;xxx…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Length&lt;/td&gt;
&lt;td&gt;xxx…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Type&lt;/td&gt;
&lt;td&gt;application/json&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;chr/0.0.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X-Powered-By&lt;/td&gt;
&lt;td&gt;Chreem&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="knowledge" scheme="https://chreem.github.io/categories/knowledge/"/>
    
    
      <category term="html" scheme="https://chreem.github.io/tags/html/"/>
    
      <category term="upload" scheme="https://chreem.github.io/tags/upload/"/>
    
  </entry>
  
  <entry>
    <title>扫雷</title>
    <link href="https://chreem.github.io/2017/03/26/20170326-search-boom/"/>
    <id>https://chreem.github.io/2017/03/26/20170326-search-boom/</id>
    <published>2017-03-26T09:04:33.000Z</published>
    <updated>2020-06-11T08:48:53.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扫雷"><a href="#扫雷" class="headerlink" title="扫雷"></a>扫雷</h1><p>突发奇想就开启了自己的游戏分类，先做个简单的扫雷练练手……<br>环境：vue-cli调试单个模块</p><p>遇到问题：</p><ul><li>vue data属性数组的深度监视</li><li>每个格子的状态及样式</li><li>按队列遍历应该“点击”的位置</li><li>胜利条件</li></ul><p>今后可能添加：</p><ul><li>插旗功能</li><li>自定义难度</li></ul><p><img src="https://cloud.githubusercontent.com/assets/12951147/24328934/d27b07f4-1229-11e7-85e1-a671d9a608d5.png" alt="boom"></p><a id="more"></a><h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><h2 id="core"><a href="#core" class="headerlink" title="core"></a>core</h2><p>用两个二维数组，分别存放雷的真实情况及样式情况，样式数组用于绑定至各格子<br>分别剥开了几个方法：</p><ul><li>初始化棋盘：<em>样式棋盘坐标大小及格子状态初始化</em></li><li>雷初始化(行，列)：<br>  逻辑棋盘由样式棋盘拷贝一份副本<br>  根据雷所占百分比计算数量并初始化逻辑棋盘<br>  生成boom💣时，逻辑棋盘[行][列]位置不应该有雷</li><li>计算没被点击的格子数量：单纯的遍历一遍逻辑棋盘而已</li><li>查找炸弹(行，列，数组，方法)（<del>名字啥的就别在意了。。。</del>）：遍历点击位置周围8格时触发方法，不包含触边及点击位置自身</li><li><strong>清除动作([确认框],[方法])</strong>：<br>  抄袭jQuery的extend判断是否深度克隆来判断是否弹出确认框<br>  执行清除动作前执行方法<br>  初始化棋盘</li></ul><p>主要流程：</p><ul><li>首次进入：初始化棋盘</li><li>切换模式：<br>  将isStart作为是否弹出询问参数执行清除动作，并在初始化前设置模式<br>  把坐标也告诉格子，在格子的点击事件里返回坐标，外层统一处理</li><li>显示所有炸弹(failed)：<br>  一局还没开始随便初始化雷，但初始化前需执行一遍清除动作，同样以isStart作为询问参数<br>  已开始则，检查failed是否因点到炸弹导致，主动放弃才弹出确认框<br>  <em>没啥问题就把逻辑棋盘整个替掉样式棋盘</em></li><li>清除按钮：仅仅执行清除动作而已，以及若已开始则需确认*3😝</li><li>点击事件：会由视图返回行列信息<br>  还没开始：清除动作雷初始化<br>  点到雷了，Boom！！！显示所有炸弹并标上一个failed，没点到就给点击位置 [ 和周围 ] 染上颜色😏，<em>以及把这些位置信息由逻辑棋盘赋给样式棋盘</em><br>  获取还没点击的格子数（当然不会把雷算进来拉🤓），若已经没有需要点的格子了就弹出Win！</li></ul><h2 id="格子"><a href="#格子" class="headerlink" title="格子"></a>格子</h2><p>格子本身只负责根据绑定值的变化来改变样式，并在点击事件中提交坐标即可</p><h3 id="需要哪些样式"><a href="#需要哪些样式" class="headerlink" title="需要哪些样式"></a>需要哪些样式</h3><p>也就分三种情况而已，如果想和xp扫雷类似根据雷的数量调整字体颜色，加几个style然后根据雷数push相应样式入数组就完事了：</p><ol><li>boom!!!💣，用-1表示</li><li>不是雷（显示周围雷的数量，数据需求范围<code>x∈[0,8] , x∈n</code>）</li><li>不知道，-1给了雷0-8给了非雷，那么：没点过的格子应该用-2喽-，-<br> 结果某菜鸡用的===””来判断是否点过 <del>就是要增加难度</del></li></ol><h3 id="格子的样式根据数据调整"><a href="#格子的样式根据数据调整" class="headerlink" title="格子的样式根据数据调整"></a>格子的样式根据数据调整</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格子根据绑定数据判断显示状态</span></span><br><span class="line"><span class="comment">//数据由主体提供，为该格子周围雷的个数</span></span><br><span class="line"><span class="comment">//默认情况该数据==='' 表示没被点过</span></span><br><span class="line">&lt;div :<span class="class"><span class="keyword">class</span></span>=<span class="string">"cls"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/其中cls为计算属性，根据传入的雷个数得出</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">    ...,</span></span><br><span class="line"><span class="regexp">    computed:&#123;</span></span><br><span class="line"><span class="regexp">        cls()&#123;</span></span><br><span class="line"><span class="regexp">            let arr = defaultClass.concat(); /</span><span class="regexp">/默认样式</span></span><br><span class="line"><span class="regexp">            if(这个格子被点了) &#123;</span></span><br><span class="line"><span class="regexp">                if(本身就是雷) &#123; arr.push(这是颗雷); &#125;</span></span><br><span class="line"><span class="regexp">                else&#123; arr.push(并不是雷并给arr带上绿帽); &#125;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            return arr;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    ...</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="extension"><a href="#extension" class="headerlink" title="extension"></a>extension</h1><p>为不为扩展目前看来也就是把有可能拎出来作为参数的部分放到vue对象外而已，今后可能用上这组件时也就把这些地方换到vue.props里完事<br>还是稍微留了点后路的，万一今后闲着蛋疼=，=<br>除了上面的<code>今后可能添加</code>外：</p><ul><li>默认模式和各模式的默认长宽、雷的个数等</li><li>获取指定范围的随机数</li><li>vue专用二维数组初始化</li><li>确认框</li><li>检查数字范围</li></ul><hr><ul><li>数据结构——队列</li></ul><hr><ul><li><del>能否在雷初始化时就把周围8个格子数量自加而非每次点击入队前计算</del><br>  那如果概率大于0.5 初始化时先默认有雷来挖出空格子怎么办</li></ul><h1 id="trouble"><a href="#trouble" class="headerlink" title="trouble"></a>trouble</h1><h2 id="vue-data属性数组的深度监视"><a href="#vue-data属性数组的深度监视" class="headerlink" title="vue data属性数组的深度监视"></a>vue data属性数组的深度监视</h2><p>对Vue2而言，data下的数组深监视的前提是数组元素是对象，所以用二维数组就不好使了：<br>GG思密达：<code>[[1,2,3,4,5],[2,2,3,4,5]]</code><br>需要这样用：<code>[{0:1,1:2,...},{0:2,2:2,...}]</code><br>还好已经写好的获取部分不需要改动</p><h2 id="按队列遍历应该“点击”的位置"><a href="#按队列遍历应该“点击”的位置" class="headerlink" title="按队列遍历应该“点击”的位置"></a>按队列遍历应该“点击”的位置</h2><p>一个地方周围是不是应该连带被显示的判断，无非是点下一个地儿之后这个位置雷==0就把周围8个格子入队罢了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">点下一个位置，该格子入队</span><br><span class="line">出队并获取队首的格子</span><br><span class="line"><span class="keyword">while</span>(该格子不为空)&#123;</span><br><span class="line">    计算这个格子周围多少雷</span><br><span class="line">    在逻辑棋盘中标记该格子数量</span><br><span class="line">    同样把这个格子中雷的数量标记给样式棋盘，剩下的就交给格子组件去做了</span><br><span class="line">    <span class="keyword">if</span>(周围没雷)</span><br><span class="line">        <span class="keyword">for</span>(点击位置周围的<span class="number">8</span>个格子)&#123;</span><br><span class="line">            <span class="keyword">if</span>(已点击过或已在队列中)&#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            循环到的这个格子入队</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="胜利条件与脑细胞（或者应该是troubling）"><a href="#胜利条件与脑细胞（或者应该是troubling）" class="headerlink" title="胜利条件与脑细胞（或者应该是troubling）"></a>胜利条件与脑细胞（或者应该是troubling）</h2><p>本来计划在每次入队时已点击格子记录自加，然而因为判断方法的漏洞导致似乎有多次重复入队（(╯‵□′)╯︵┻━┻不是让他判断在队列就跳过了么），依然没想清楚为何<br>目前的做法是每次点击队列循环完事之后遍历逻辑棋盘统计没点过的位置数量，简单粗暴</p><p>为图省事队列用的数组，出队则是<code>arr=arr.slice(1)</code><br>仔细想了想，队列保存和出队方式改改的可能性：<br>保留一个游标保存当前指向的元素下标，出队时返回该下标元素然后下标++而不改变原有数组<br>while(格子不为空)中使用find就不会漏掉元素了，说不定还能顺便保存点击记录<br><del>不过岂不是徒增队列长度？得不偿失？还是简单粗暴好了</del></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;扫雷&quot;&gt;&lt;a href=&quot;#扫雷&quot; class=&quot;headerlink&quot; title=&quot;扫雷&quot;&gt;&lt;/a&gt;扫雷&lt;/h1&gt;&lt;p&gt;突发奇想就开启了自己的游戏分类，先做个简单的扫雷练练手……&lt;br&gt;环境：vue-cli调试单个模块&lt;/p&gt;
&lt;p&gt;遇到问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vue data属性数组的深度监视&lt;/li&gt;
&lt;li&gt;每个格子的状态及样式&lt;/li&gt;
&lt;li&gt;按队列遍历应该“点击”的位置&lt;/li&gt;
&lt;li&gt;胜利条件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今后可能添加：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插旗功能&lt;/li&gt;
&lt;li&gt;自定义难度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/12951147/24328934/d27b07f4-1229-11e7-85e1-a671d9a608d5.png&quot; alt=&quot;boom&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="games" scheme="https://chreem.github.io/categories/games/"/>
    
    
      <category term="vue" scheme="https://chreem.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>npm发布流程</title>
    <link href="https://chreem.github.io/2017/03/17/20170317-mock-server/"/>
    <id>https://chreem.github.io/2017/03/17/20170317-mock-server/</id>
    <published>2017-03-17T23:53:18.000Z</published>
    <updated>2020-06-11T08:48:53.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Publish-Mock-Server-to-NPM"><a href="#Publish-Mock-Server-to-NPM" class="headerlink" title="Publish Mock-Server to NPM"></a>Publish Mock-Server to NPM</h1><p>图省事用的express，数据就用*.json保存，假装自己有个mongodb。<br>同时测试npm发布：<br><a href="https://www.npmjs.com/package/chr-mock" target="_blank" rel="noopener"><img src="https://img.shields.io/npm/v/chr-mock.svg?style=flat-square" alt="chr-mock"></a> <a href="https://travis-ci.org/Chreem/chr-mock" target="_blank" rel="noopener"><img src="https://img.shields.io/travis/Chreem/chr-mock.svg?style=flat-square" alt="Travis"></a> <a href="https://www.npmjs.com/package/chr-mock" target="_blank" rel="noopener"><img src="https://img.shields.io/npm/l/chr-mock.svg?style=flat-square" alt="npm"></a></p><a id="more"></a><h1 id="前置需求"><a href="#前置需求" class="headerlink" title="前置需求"></a>前置需求</h1><ol><li>修改<code>package.json</code></li><li><code>commander</code>命令行辅助工具</li><li><code>express</code>提供mock服务</li></ol><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>自定义命令需要在package.json里修改bin属性，增加命令执行入口<br>增加<code>preferGlobal</code>提示全局安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"preferGlobal"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"bin"</span>: &#123;</span><br><span class="line">    <span class="string">"chr"</span>: <span class="string">"./index.js"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>或者装好后添加至全局：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> chr-mock</span><br><span class="line">~/chr-mock$ npm link</span><br></pre></td></tr></table></figure><h2 id="commander"><a href="#commander" class="headerlink" title="commander"></a><a href="https://www.npmjs.com/package/commander" target="_blank" rel="noopener">commander</a></h2><p>node命令行用<br>能很方便的配置各类参数以及自动生成帮助文档–help  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="comment">// 见的比较多的应该是#!/bin/bash，此处同理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"><span class="keyword">var</span> filename;</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">    .command(<span class="string">'watch [file]'</span>)</span><br><span class="line">    .description(<span class="string">'Add a file to watch'</span>)</span><br><span class="line">    .action(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">        filename = file;</span><br><span class="line">    &#125;);</span><br><span class="line">program         <span class="comment">// 之所以单列一条而没和上面放一起是为了能正常显示帮助文档</span></span><br><span class="line">    .option(<span class="string">'-p, --port &lt;n&gt;'</span>, <span class="string">'Add port to listen, default is 8080'</span>, /^[<span class="number">1</span><span class="number">-9</span>]\d*$/, <span class="number">8080</span>);</span><br><span class="line">program.parse(process.argv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> filename === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    program.outputHelp();</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 参数不对显示帮助文档</span></span><br><span class="line"><span class="comment">E:\Web\node\chr-mock&gt;node index.js watch</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Usage: index [options] [command]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Commands:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    watch [file]  Add a file to watch</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Options:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    -h, --help      output usage information</span></span><br><span class="line"><span class="comment">    -p, --port &lt;n&gt;  Add port to listen, default is 8080</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'file:'</span> + filename);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'port:'</span> + program.port);</span><br></pre></td></tr></table></figure><h2 id="express"><a href="#express" class="headerlink" title="express"></a><a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">express</a></h2><p>后面要做的基本上就在这里的watch.js里写了<br>根据上面命令行拿到的文件及监听端口运行express  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* index.js */</span></span><br><span class="line"><span class="keyword">const</span> watch = <span class="built_in">require</span>(<span class="string">'./watch.js'</span>);</span><br><span class="line">... <span class="comment">//上一步</span></span><br><span class="line">watch.run(filename, program.port);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* watch.js */</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line">    , app = express();</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    run(file, port)&#123;</span><br><span class="line">        app.get(<span class="string">'/'</span>, (req, res)=&gt;&#123;</span><br><span class="line">            res.send(<span class="string">'hello~'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        app.listen(port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以及各种中间件：  </p><ol><li>跨域：cors</li><li>解析post body：body-parser</li></ol><p>其他：</p><ol><li>url</li><li>path</li><li>jsonfile</li></ol><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h2><p>首先要做的就是根据路由来匹配访问字段，没啥疑问应该<br>该节参考<a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="noopener">api 路由</a><br>数据深度不定，无法使用<code>express.Router</code>，需通过<code>url.parse(*).pathname</code>自行解析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">run(file, port)&#123;</span><br><span class="line">    app.all(<span class="string">'*'</span>,(req, res)=&gt;&#123;</span><br><span class="line">        <span class="keyword">let</span> params = url.parse(req.originalUrl).pathname</span><br><span class="line">            .replace(<span class="regexp">/^\//</span>,<span class="string">''</span>)</span><br><span class="line">            .replace(<span class="regexp">/\/$/</span>,<span class="string">''</span>)</span><br><span class="line">            .split(<span class="string">'/'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数加工处理   及各种判断</span></span><br><span class="line">        <span class="comment">// 请求分类     以及各种判断</span></span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">    &#125;)</span><br><span class="line">    app.listen(port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="发布至npm"><a href="#发布至npm" class="headerlink" title="发布至npm"></a>发布至npm</h1><h2 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h2><p>只需要简单几步就能完成……：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 跳过第二步</span></span><br><span class="line"><span class="comment"># 2. 注册</span></span><br><span class="line">$ <span class="built_in">cd</span> chr-mock             <span class="comment"># 至项目目录</span></span><br><span class="line">~/chr-mock$ npm login     <span class="comment"># 登录</span></span><br><span class="line">~/chr-mock$ npm publish   <span class="comment"># 发布</span></span><br></pre></td></tr></table></figure><p>然后就能从公有仓库下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g chr-mock</span><br><span class="line">chr watch data.json</span><br></pre></td></tr></table></figure><h2 id="配合travis-ci自动发布"><a href="#配合travis-ci自动发布" class="headerlink" title="配合travis ci自动发布"></a>配合travis ci自动发布</h2><ol><li><p>github &amp; travis ci配置</p></li><li><p>查看完整的login token, 通常在<code>~/.npmrc</code>里</p></li><li><p>Travis CI配置环境变量存入token</p></li><li><p>.travis.yml添加deploy信息：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">provider:</span> <span class="string">npm</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">$npm_login_email</span></span><br><span class="line">    <span class="attr">api_key:</span> <span class="string">$npm_token_key</span></span><br><span class="line">    <span class="attr">on:</span></span><br><span class="line">        <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li><li><p>git push</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Publish-Mock-Server-to-NPM&quot;&gt;&lt;a href=&quot;#Publish-Mock-Server-to-NPM&quot; class=&quot;headerlink&quot; title=&quot;Publish Mock-Server to NPM&quot;&gt;&lt;/a&gt;Publish Mock-Server to NPM&lt;/h1&gt;&lt;p&gt;图省事用的express，数据就用*.json保存，假装自己有个mongodb。&lt;br&gt;同时测试npm发布：&lt;br&gt;&lt;a href=&quot;https://www.npmjs.com/package/chr-mock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://img.shields.io/npm/v/chr-mock.svg?style=flat-square&quot; alt=&quot;chr-mock&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://travis-ci.org/Chreem/chr-mock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://img.shields.io/travis/Chreem/chr-mock.svg?style=flat-square&quot; alt=&quot;Travis&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://www.npmjs.com/package/chr-mock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://img.shields.io/npm/l/chr-mock.svg?style=flat-square&quot; alt=&quot;npm&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="practice" scheme="https://chreem.github.io/categories/practice/"/>
    
    
      <category term="npm" scheme="https://chreem.github.io/tags/npm/"/>
    
  </entry>
  
</feed>
