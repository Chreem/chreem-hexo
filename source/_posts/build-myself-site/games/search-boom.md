---
title: 非常寥批的扫雷
date: 2017-03-26 09:04:33
categories: games
tags: vue
---
# 扫雷

突发奇想就开启了自己的游戏分类，先做个简单的扫雷练练手……  
环境：没啥环境，用vue-cli调试单个模块而已（就是偏爱vue😜）  

遇到问题：

* vue data属性数组的深度监视
* 每个格子的状态及样式
* 按队列遍历应该“点击”的位置
* 胜利条件与脑细胞的抉择（我选择多活几年😂）

今后可能添加：

* 插旗功能
* 自定义难度

![boom](https://cloud.githubusercontent.com/assets/12951147/24328934/d27b07f4-1229-11e7-85e1-a671d9a608d5.png)

<!--more-->

## 基本流程

转念一想就不画流程图了，~~懒虫上脑了~~，随便写写拉倒

### core

用两个二维数组，分别存放雷的真实情况及样式情况，样式数组用于绑定至各格子  
分别剥开了几个方法：

* 初始化棋盘：*样式棋盘坐标大小及格子状态初始化*
* 雷初始化(行，列)：  
    逻辑棋盘由样式棋盘拷贝一份副本  
    根据雷所占百分比计算数量并初始化逻辑棋盘  
    生成boom💣时，逻辑棋盘\[行\]\[列\]位置不应该有雷
* 计算没被点击的格子数量：单纯的遍历一遍逻辑棋盘而已
* 查找炸弹(行，列，数组，方法)（~~名字啥的就别在意了。。。~~）：遍历点击位置周围8格时触发方法，不包含触边及点击位置自身
* **清除动作([确认框],[方法])**：  
    抄袭jQuery的extend判断是否深度克隆来判断是否弹出确认框  
    执行清除动作前执行方法  
    初始化棋盘

主要流程：

* 首次进入：初始化棋盘
* 切换模式：  
    将isStart作为是否弹出询问参数执行清除动作，并在初始化前设置模式  
    把坐标也告诉格子，在格子的点击事件里返回坐标，外层统一处理
* 显示所有炸弹(failed)：  
    一局还没开始随便初始化雷，但初始化前需执行一遍清除动作，同样以isStart作为询问参数  
    已开始则，检查failed是否因点到炸弹导致，主动放弃才弹出确认框  
    *没啥问题就把逻辑棋盘整个替掉样式棋盘*
* 清除按钮：仅仅执行清除动作而已，以及若已开始则需确认*3😝
* 点击事件：会由视图返回行列信息  
    还没开始：清除动作雷初始化  
    点到雷了，Boom！！！显示所有炸弹并标上一个failed，没点到就给点击位置 \[ 和周围 \] 染上颜色😏，*以及把这些位置信息由逻辑棋盘赋给样式棋盘*  
    获取还没点击的格子数（当然不会把雷算进来拉🤓），若已经没有需要点的格子了就弹出Win！

### 格子

格子本身只负责根据绑定值的变化来改变样式，并在点击事件中提交坐标即可

#### 需要哪些样式

也就分三种情况而已，如果想和xp扫雷类似根据雷的数量调整字体颜色，加几个style然后根据雷数push相应样式入数组就完事了：

1. boom!!!💣，用-1表示
2. 不是雷（显示周围雷的数量，数据需求范围`x∈[0,8] , x∈n`）
3. 不知道，-1给了雷0-8给了非雷，那么：没点过的格子应该用-2喽-，-  
    结果某菜鸡用的===""来判断是否点过 ~~就是要增加难度~~

#### 格子的样式根据数据调整

```js
//格子根据绑定数据判断显示状态
//数据由主体提供，为该格子周围雷的个数
//默认情况该数据==='' 表示没被点过
<div :class="cls"></div>

//其中cls为计算属性，根据传入的雷个数得出
export default {
    ...,
    computed:{
        cls(){
            let arr = defaultClass.concat(); //默认样式
            if(这个格子被点了) {
                if(本身就是雷) { arr.push(这是颗雷); }
                else{ arr.push(并不是雷并给arr带上绿帽); }
            }
            return arr;
        }
    },
    ...
}
```

## extension

为不为扩展目前看来也就是把有可能拎出来作为参数的部分放到vue对象外而已，今后可能用上这组件时也就把这些地方换到vue.props里完事  
还是稍微留了点后路的，万一今后闲着蛋疼=，=  
除了上面的`今后可能添加`外：

* 默认模式和各模式的默认长宽、雷的个数等
* 获取指定范围的随机数
* vue专用二维数组初始化
* 确认框
* 检查数字范围

---

* 数据结构——队列

---

* ~~能否在雷初始化时就把周围8个格子数量自加而非每次点击入队前计算~~  
    那如果概率大于0.5 初始化时先默认有雷来挖出空格子怎么办

## trouble

### vue data属性数组的深度监视  

对Vue2而言，data下的数组深监视的前提是数组元素是对象，所以用二维数组就不好使了：  
GG思密达：`[[1,2,3,4,5],[2,2,3,4,5]]`  
需要这样用：`[{0:1,1:2,...},{0:2,2:2,...}]`  
还好已经写好的获取部分不需要改动

### 按队列遍历应该“点击”的位置

一个地方周围是不是应该连带被显示的判断，无非是点下一个地儿之后这个位置雷==0就把周围8个格子入队罢了

```js
点下一个位置，该格子入队
出队并获取队首的格子
while(该格子不为空){
    计算这个格子周围多少雷
    在逻辑棋盘中标记该格子数量
    同样把这个格子中雷的数量标记给样式棋盘，剩下的就交给格子组件去做了
    if(周围没雷)
        for(点击位置周围的8个格子){
            if(已点击过或已在队列中){ continue; }
            循环到的这个格子入队
        }
}
```

### 胜利条件与脑细胞（或者应该是troubling）

本来计划在每次入队时已点击格子记录自加，然而因为判断方法的漏洞导致似乎有多次重复入队（(╯‵□′)╯︵┻━┻不是让他判断在队列就跳过了么），依然没想清楚为何  
目前的做法是每次点击队列循环完事之后遍历逻辑棋盘统计没点过的位置数量，简单粗暴

为图省事队列用的数组，出队则是`arr=arr.slice(1)`  
仔细想了想，队列保存和出队方式改改的可能性：  
保留一个游标保存当前指向的元素下标，出队时返回该下标元素然后下标++而不改变原有数组  
while(格子不为空)中使用find就不会漏掉元素了，说不定还能顺便保存点击记录  
~~不过岂不是徒增队列长度？得不偿失？还是简单粗暴好了~~